<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<!-- headlinks removed -->
	<link rel="shortcut icon" href="../../../../misc/favicon.ico"/>
    <title>MatrixSwitch - ESL - The Electronic Structure Library
</title>
    <style type="text/css">/*<![CDATA[*/ @import "../../../../skins/offline/main.css"; /*]]>*/</style>
    <link rel="stylesheet" type="text/css" media="print" href="../../../../skins/common/commonPrint.css" />
    <!--[if lt IE 5.5000]><style type="text/css">@import "../../../../skins/monobook/IE50Fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "../../../../skins/monobook/IE55Fixes.css";</style><![endif]-->
    <!--[if IE 6]><style type="text/css">@import "../../../../skins/monobook/IE60Fixes.css";</style><![endif]-->
    <!--[if IE]><script type="text/javascript" src="../../../../skins/common/IEFixes.js"></script>
    <meta http-equiv="imagetoolbar" content="no" /><![endif]-->
    <script type="text/javascript" src="../../../../skins/common/wikibits.js"></script>
    <script type="text/javascript" src="../../../../skins/offline/md5.js"></script>
    <script type="text/javascript" src="../../../../skins/offline/utf8.js"></script>
    <script type="text/javascript" src="../../../../skins/offline/lookup.js"></script>
                      </head>
  <body class="mediawiki ltr ns-0 ns-subject page-MatrixSwitch">
    <div id="globalWrapper">
      <div id="column-content">
	<div id="content">
	  <a name="top" id="contentTop"></a>
	        <h1 class="firstHeading">MatrixSwitch</h1>
	  <div id="bodyContent">
	    <h3 id="siteSub">From ESL</h3>
	    <div id="contentSub"></div>
	    	    	    <!-- start content -->
	    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div style="float: right; background: AliceBlue; padding: 10px; margin-left: 10px; margin-bottom: 10px; border-style: solid; border-width: 1px; width: 35%">
<p><b>Source authors:</b>
</p><p><a rel="nofollow" target="_blank" class="external text" href="http://www.nanogune.eu/en/research/theory/people/fabiano-corsetti/">Fabiano Corsetti</a>, CIC nanoGUNE, Spain
</p><p><b>Responsible for the ESL entry:</b>
</p><p><a href="../../../../articles/f/a/b/User:Fabiano.corsetti.html" title="User:Fabiano.corsetti">Fabiano Corsetti</a>
</p><p><b>License:</b> BSD (see <code>README.md</code> in the source code)
</p><p><b>Type of development:</b> Internal
</p><p><b>Download:</b> <a rel="nofollow" target="_blank" class="external text" href="https://launchpad.net/matrixswitch/">Here</a>
</p>
</div>
<p>MatrixSwitch is a module which acts as an intermediary interface layer between high-level routines for physics-related algorithms and low-level routines dealing with matrix storage and manipulation. This allows the high-level routines to be written in a way which is physically transparent, and enables them to switch seamlessly between different software implementations of the matrix operations.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Theory"><span class="tocnumber">1</span> <span class="toctext">Theory</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Installation"><span class="tocnumber">2</span> <span class="toctext">Installation</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Prerequisites"><span class="tocnumber">2.1</span> <span class="toctext">Prerequisites</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Instructions"><span class="tocnumber">2.2</span> <span class="toctext">Instructions</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Tests"><span class="tocnumber">2.3</span> <span class="toctext">Tests</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Usage"><span class="tocnumber">3</span> <span class="toctext">Usage</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Documentation"><span class="tocnumber">4</span> <span class="toctext">Documentation</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Storage_formats"><span class="tocnumber">4.1</span> <span class="toctext">Storage formats</span></a>
<ul>
<li class="toclevel-3 tocsection-9"><a href="#s.3Fden:_simple_dense_.28serial_distribution.29"><span class="tocnumber">4.1.1</span> <span class="toctext">s?den: simple dense (serial distribution)</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#p.3Fdbc:_dense_block_cyclic_.28parallel_distribution.29"><span class="tocnumber">4.1.2</span> <span class="toctext">p?dbc: dense block cyclic (parallel distribution)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-11"><a href="#Implementations_of_the_matrix_operations"><span class="tocnumber">4.2</span> <span class="toctext">Implementations of the matrix operations</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="#ref:_reference"><span class="tocnumber">4.2.1</span> <span class="toctext">ref: reference</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#lap:_LAPACK.2FScaLAPACK"><span class="tocnumber">4.2.2</span> <span class="toctext">lap: LAPACK/ScaLAPACK</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-14"><a href="#Operation_tables"><span class="tocnumber">4.3</span> <span class="toctext">Operation tables</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="#mm_multiply"><span class="tocnumber">4.3.1</span> <span class="toctext">mm_multiply</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#m_add"><span class="tocnumber">4.3.2</span> <span class="toctext">m_add</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="#m_trace"><span class="tocnumber">4.3.3</span> <span class="toctext">m_trace</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#mm_trace"><span class="tocnumber">4.3.4</span> <span class="toctext">mm_trace</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#m_scale"><span class="tocnumber">4.3.5</span> <span class="toctext">m_scale</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#m_set"><span class="tocnumber">4.3.6</span> <span class="toctext">m_set</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#m_set_element"><span class="tocnumber">4.3.7</span> <span class="toctext">m_set_element</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#m_get_element"><span class="tocnumber">4.3.8</span> <span class="toctext">m_get_element</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-23"><a href="#Future_developments"><span class="tocnumber">4.4</span> <span class="toctext">Future developments</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="#Programming_interface"><span class="tocnumber">5</span> <span class="toctext">Programming interface</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="#Public_variables"><span class="tocnumber">5.1</span> <span class="toctext">Public variables</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#Public_types"><span class="tocnumber">5.2</span> <span class="toctext">Public types</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#Public_subroutines"><span class="tocnumber">5.3</span> <span class="toctext">Public subroutines</span></a>
<ul>
<li class="toclevel-3 tocsection-28"><a href="#Matrix_setup.2Fcreation.2Fdestruction"><span class="tocnumber">5.3.1</span> <span class="toctext">Matrix setup/creation/destruction</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#Matrix_operations"><span class="tocnumber">5.3.2</span> <span class="toctext">Matrix operations</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Theory">Theory</span></h2>
<p>Many computational physics algorithms are based on sequences of matrix operations (e.g., iterative Kohn-Sham eigensolvers). These are typically described using standard mathematical notation, which does not depend on the specifics of the computational implementation, i.e., how the matrices are stored and manipulated in the code. Many different storage formats exist, depending also on the architecture (serial/parallel) and the type of matrix (dense/sparse), as well as many libraries that can perform matrix operations for particular storage formats. Libraries can be more or less transparent in the way the matrices are handled: some hide the details of the storage scheme in a derived type, while others require auxiliary data to be carried around by the user. Generally, the matrix operations themselves are contained within subroutines that are simple to call. However, the interface is specific to each library.
</p><p>The aim of MatrixSwitch is to provide a simple, unified interface to allow users to code physics-related algorithms with a minimal amount of knowledge of the underlying implementation of the matrix algebra, and, crucially, to be able to <i>switch</i> between different implementations without modifying their code. Therefore, if a new matrix algebra library is released which is particularly suited to a new architecture, this simply has to be interfaced within MatrixSwitch to start being used.
</p><p>The emphasis for this project is on implementing physically relevant operations in as simple a way as possible. Therefore, the focus will be on the core set of functionalities typically needed for physics (particularly electronic structure), and on streamlining the interface to make programs easy to read, understand, and code in terms of the mathematical formulation of the algorithm.
</p>
<h2><span class="mw-headline" id="Installation">Installation</span></h2>
<h3><span class="mw-headline" id="Prerequisites">Prerequisites</span></h3>
<p>The basic routines can be installed with only a Fortran compiler. This will allow you to use the <code>s?den</code> format and <code>ref</code> operations.
</p><p>Optional requirements are:
</p>
<ul>
<li> BLAS + LAPACK for <code>lap</code> operations with the <code>s?den</code> format
</li>
<li> MPI + BLAS + LAPACK + ScaLAPACK for the <code>p?dbc</code> format
</li>
</ul>
<h3><span class="mw-headline" id="Instructions">Instructions</span></h3>
<ol>
<li> Enter the <code>src</code> directory.
</li>
<li> Copy <code>make.inc.example</code> to <code>make.inc</code> and modify it to suit your needs. Available options for <code>FPPFLAGS</code> are:
<ul>
<li> <code>-DMPI</code>: enable MPI parallel routines
</li>
<li> <code>-DLAP</code>: enable LAPACK routines
</li>
<li> <code>-DSLAP</code>: enable ScaLAPACK routines (requires <code>-DMPI</code>)
</li>
<li> <code>-DCONV</code>: enable automatic conversion of scalar types (real/complex) to agree with matrix definitions (real/complex). Note that conversions from complex to real will simply discard the imaginary part.
</li>
</ul>
</li>
<li> Type <code>make</code>.
</li>
</ol>
<h3><span class="mw-headline" id="Tests">Tests</span></h3>
<p>The <code>examples</code> directory contains a number of small programs that make use of MatrixSwitch. These can be useful both for testing the installation and for learning how to use the library. To compile them:
</p>
<ol>
<li> Enter the <code>examples</code> directory.
</li>
<li> Copy <code>make.inc.example</code> to <code>make.inc</code> and modify it to suit your needs. Be aware that <code>make.inc</code> in the <code>src</code> directory will also be used.
</li>
<li> Type <code>make</code>.
</li>
</ol>
<p>Each example contains a header explaining what the program does and providing sample output to compare against.
</p>
<h2><span class="mw-headline" id="Usage">Usage</span></h2>
<p><code>MatrixSwitch</code> is a module that you can <code>use</code> in Fortran routines. Note that both the <code>.a</code> and <code>.mod</code> files need to be available. An example compilation command for a code using MatrixSwitch is: <code>gfortran MyCode.f90 /path/to/MatrixSwitch-x.y.z/src/MatrixSwitch.a -I/path/to/MatrixSwitch-x.y.z/src/ -llapack -lblas</code>
</p>
<h2><span class="mw-headline" id="Documentation">Documentation</span></h2>
<p>The best way of learning how to use MatrixSwitch is by example. See the examples in the <code>examples</code> directory for this. In a typical code, there are four steps that are followed:
</p>
<ol>
<li> Setup the matrices:<br /> Matrices need to first be declared with the MatrixSwitch public type <code>matrix</code>. There are then two roots to initialising a matrix. The easiest is to do so from scratch, by calling <code>m_allocate</code>. However, if the matrix data already exists (e.g., if it comes from a different section of the code) and is in the correct format, it can simply be registered into the TYPE(MATRIX) variable, by calling the appropriate subroutine; for example, two-dimensional arrays can be registered as <code>s?den</code> matrices by calling <code>m_register_sden</code>. In this case, the data is not copied; rather, elements of the TYPE(MATRIX) variable are set to point to the existing array(s). Note that some storage formats may require additional setup operations (detailed <a href="../../../../articles/m/a/t/MatrixSwitch.html#Storage_formats" title="MatrixSwitch">below</a>).
</li>
<li> Fill the matrices:<br /> Matrix element values can be set by calling <code>m_set</code> and <code>m_set_element</code>.
</li>
<li> Perform some matrix operations:<br /> See the list of <a href="../../../../articles/m/a/t/MatrixSwitch.html#Matrix_operations" title="MatrixSwitch">available matrix operations</a>.
</li>
<li> Destroy the matrices:<br /> Matrices can be deallocated by calling <code>m_deallocate</code>.
</li>
</ol>
<h3><span class="mw-headline" id="Storage_formats">Storage formats</span></h3>
<p>The storage formats that can currently be used with MatrixSwitch are listed below. A <code>?</code> in a format name stands for either <code>d</code> (real matrix) or <code>z</code> (complex matrix). So far, only two storage formats have been implemented, both for dense matrices. Sparse formats will be introduced in the very near future.
</p>
<h4><span class="mw-headline" id="s.3Fden:_simple_dense_.28serial_distribution.29"><code>s?den</code>: simple dense (serial distribution)</span></h4>
<p>This is the most basic type of storage: a two-dimensional array storing the matrix elements on a single core. It can be used to perform operations with <code>ref</code> or <code>lap</code>.
</p><p>Requirements:
</p>
<ul>
<li> External libraries: none
</li>
<li> Usage: no special routines need to be called to use this format
</li>
</ul>
<p>Storage details within <code>type matrix</code>:
</p>
<ul>
<li> <code>dval</code>/<code>zval</code>, dimension (<code>dim1</code>,<code>dim2</code>): stores the matrix elements (real/complex matrix)
</li>
</ul>
<h4><span class="mw-headline" id="p.3Fdbc:_dense_block_cyclic_.28parallel_distribution.29"><code>p?dbc</code>: dense block cyclic (parallel distribution)</span></h4>
<p>This format follows the standard used by ScaLAPACK for parallel distribution of a dense matrix (see <a rel="nofollow" target="_blank" class="external text" href="http://netlib.org/scalapack/slug/node75.html#SECTION04431000000000000000">this page</a> for some introduction). This makes it is extremely easy to use MatrixSwitch in a small portion of a larger code which already uses ScaLAPACK, as it allows for matrices to be passed in and out of the MatrixSwitch section (see <code>ms_lap_icontxt</code>, <code>ms_scalapack_setup</code>, <code>m_register_pdbc</code>).
</p><p>This format can be used to perform operations with <code>lap</code>.
</p><p>Requirements:
</p>
<ul>
<li> External libraries: MPI + BLAS + LAPACK + ScaLAPACK
</li>
<li> Usage: <code>ms_scalapack_setup</code> needs to be called at the start of the code
</li>
</ul>
<p>Storage details within <code>type matrix</code>:
</p>
<ul>
<li> <code>iaux1</code>, dimension (<code>9</code>): stores the BLACS array descriptor
</li>
<li> <code>iaux2</code>, dimension (<code>2</code>): stores the size of the local portion of the matrix
</li>
<li> <code>dval</code>/<code>zval</code>, dimension (<code>iaux2(1)</code>,<code>iaux2(2)</code>): stores the local matrix elements (real/complex matrix)
</li>
</ul>
<h3><span class="mw-headline" id="Implementations_of_the_matrix_operations">Implementations of the matrix operations</span></h3>
<p>A general overview of the different computational implementations of the MatrixSwitch matrix operations is given below. These implementations need not be tied to specific storage formats, and vice versa. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#Operation_tables" title="MatrixSwitch">next section</a> for a more detailed description of which storage formats can be used with which implementations for a particular operation.
</p>
<h4><span class="mw-headline" id="ref:_reference"><code>ref</code>: reference</span></h4>
<p>The reference implementation is coded within MatrixSwitch. It can be used with <code>s?den</code> matrices. It is not fast, but is useful for checking results and does not require any external libraries.
</p><p>Requirements:
</p>
<ul>
<li> External libraries: none
</li>
</ul>
<h4><span class="mw-headline" id="lap:_LAPACK.2FScaLAPACK"><code>lap</code>: LAPACK/ScaLAPACK</span></h4>
<p>This implementation makes use of BLAS + LAPACK to operate on <code>s?den</code> matrices, and additionally ScaLAPACK to operate on <code>p?dbc</code> matrices. It should be considerably faster than <code>ref</code>, but the performance will depend on the external libraries provided by the user.
</p><p>Requirements:
</p>
<ul>
<li> External libraries:
<ul>
<li> Serial: BLAS + LAPACK
</li>
<li> Parallel: MPI + BLAS + LAPACK + ScaLAPACK
</li>
</ul>
</li>
</ul>
<h3><span class="mw-headline" id="Operation_tables">Operation tables</span></h3>
<p>This section contains a comprehensive list of the allowed combinations of storage formats and implementations of the matrix operations. There is a separate table for each <a href="../../../../articles/m/a/t/MatrixSwitch.html#Matrix_operations" title="MatrixSwitch">matrix operation subroutine</a>. The table lists the input and output matrices required by the subroutine. Each row gives a possible combination of storage formats that can be used when calling it. The last column then lists the possible implementations of the operation for the particular combination of storage formats; usually only one implementation is available, but sometimes more than one is. The three-character code for the implementation should be passed to the subroutine in the <code>label</code> variable; if <code>label</code> is absent, the default implementation for the storage formats provided will be called.
</p>
<h4><span class="mw-headline" id="mm_multiply"><code>mm_multiply</code></span></h4>
<table border="1" cellpadding="5">
<tr>
<td> <code>A</code>
</td>
<td> <code>B</code>
</td>
<td> <code>C</code>
</td>
<td> <code>label</code>
</td></tr>
<tr>
<td rowspan="2"> <code>s?den</code>
</td>
<td rowspan="2"> <code>s?den</code>
</td>
<td rowspan="2"> <code>s?den</code>
</td>
<td> <code>ref</code> (default)
</td></tr>
<tr>
<td> <code>lap</code>
</td></tr>
<tr>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td> <code>lap</code> (default)
</td></tr></table>
<h4><span class="mw-headline" id="m_add"><code>m_add</code></span></h4>
<table border="1" cellpadding="5">
<tr>
<td> <code>A</code>
</td>
<td> <code>C</code>
</td>
<td> <code>label</code>
</td></tr>
<tr>
<td rowspan="2"> <code>s?den</code>
</td>
<td rowspan="2"> <code>s?den</code>
</td>
<td> <code>ref</code> (default)
</td></tr>
<tr>
<td> <code>lap</code> (redirects to <code>ref</code>)
</td></tr>
<tr>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td> <code>lap</code> (default)
</td></tr></table>
<h4><span class="mw-headline" id="m_trace"><code>m_trace</code></span></h4>
<table border="1" cellpadding="5">
<tr>
<td> <code>A</code>
</td>
<td> <code>label</code>
</td></tr>
<tr>
<td rowspan="2"> <code>s?den</code>
</td>
<td> <code>ref</code> (default)
</td></tr>
<tr>
<td> <code>lap</code> (redirects to <code>ref</code>)
</td></tr>
<tr>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td> <code>lap</code> (default) [1]
</td></tr></table>
<p>[1] Note that a common bug in the ScaLAPACK routine <code>pzlatra</code> causes the output to have an imaginary part of zero when using <code>pzdbc</code>.
</p>
<h4><span class="mw-headline" id="mm_trace"><code>mm_trace</code></span></h4>
<table border="1" cellpadding="5">
<tr>
<td> <code>A</code>
</td>
<td> <code>B</code>
</td>
<td> <code>label</code>
</td></tr>
<tr>
<td rowspan="2"> <code>sdden</code>
</td>
<td rowspan="2"> <code>sdden</code>
</td>
<td> <code>ref</code> (default)
</td></tr>
<tr>
<td> <code>lap</code>
</td></tr>

<tr>
<td rowspan="2"> <code>szden</code>
</td>
<td rowspan="2"> <code>szden</code>
</td>
<td> <code>ref</code> (default)
</td></tr>
<tr>
<td> <code>lap</code> (redirects to <code>ref</code>)
</td></tr>
<tr>
<td rowspan="1"> <code>pddbc</code>
</td>
<td rowspan="1"> <code>pddbc</code>
</td>
<td> <code>lap</code> (default)
</td></tr>
<tr>
<td rowspan="2"> <code>pzdbc</code>
</td>
<td rowspan="2"> <code>pzdbc</code>
</td>
<td> <code>ref</code> (default) [1]
</td></tr>
<tr>
<td> <code>lap</code> (redirects to <code>ref</code>)
</td></tr>
</table>
<p>[1] Note that identical parallel distributions for <code>A</code> and <code>B</code> are required.
</p>
<h4><span class="mw-headline" id="m_scale"><code>m_scale</code></span></h4>
<table border="1" cellpadding="5">
<tr>
<td> <code>C</code>
</td>
<td> <code>label</code>
</td></tr>
<tr>
<td rowspan="2"> <code>s?den</code>
</td>
<td> <code>ref</code> (default) [1]
</td></tr>
<tr>
<td> <code>lap</code> (redirects to <code>ref</code>)
</td></tr>
<tr>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td> <code>lap</code> (default - redirects to [1])
</td></tr></table>
<h4><span class="mw-headline" id="m_set"><code>m_set</code></span></h4>
<table border="1" cellpadding="5">
<tr>
<td> <code>C</code>
</td>
<td> <code>label</code>
</td></tr>
<tr>
<td rowspan="2"> <code>s?den</code>
</td>
<td> <code>ref</code> (default)
</td></tr>
<tr>
<td> <code>lap</code> (redirects to <code>ref</code>)
</td></tr>
<tr>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td> <code>lap</code> (default)
</td></tr></table>
<h4><span class="mw-headline" id="m_set_element"><code>m_set_element</code></span></h4>
<table border="1" cellpadding="5">
<tr>
<td> <code>C</code>
</td>
<td> <code>label</code>
</td></tr>
<tr>
<td rowspan="2"> <code>s?den</code>
</td>
<td> <code>ref</code> (default)
</td></tr>
<tr>
<td> <code>lap</code> (redirects to <code>ref</code>)
</td></tr>
<tr>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td> <code>lap</code> (default)
</td></tr></table>
<h4><span class="mw-headline" id="m_get_element"><code>m_get_element</code></span></h4>
<table border="1" cellpadding="5">
<tr>
<td> <code>C</code>
</td>
<td> <code>label</code>
</td></tr>
<tr>
<td rowspan="2"> <code>s?den</code>
</td>
<td> <code>ref</code> (default)
</td></tr>
<tr>
<td> <code>lap</code> (redirects to <code>ref</code>)
</td></tr>
<tr>
<td rowspan="1"> <code>p?dbc</code>
</td>
<td> <code>lap</code> (default)
</td></tr></table>
<h3><span class="mw-headline" id="Future_developments">Future developments</span></h3>
<ul>
<li> Sparse matrix formats: distributed compressed row/column, block sparse
</li>
<li> Hermitian matrices
</li>
</ul>
<h2><span class="mw-headline" id="Programming_interface">Programming interface</span></h2>
<p>Note that some entries are specifically of use for a particular storage format or implementation. This is marked in [<span style="color: red">red</span>] at the beginning of the description.
</p>
<h3><span class="mw-headline" id="Public_variables">Public variables</span></h3>
<hr />
<p><code>ms_lap_icontxt</code> INTEGER<br /> [<span style="color: red"><code>p?dbc</code></span>] BLACS context handle used by MatrixSwitch. This is made public to allow allocated and registered <code>p?dbc</code> matrices to be placed in the same context. This can be done in two ways:
</p>
<ul>
<li> If BLACS has already been initialised, the existing context handle can be passed to MatrixSwitch via <code>ms_scalapack_setup</code>, which will then set <code>ms_lap_icontxt</code> to the same value. Note that in this case the other variables passed to <code>ms_scalapack_setup</code> need to be consistent with the process grid enclosed in the existing context.
</li>
<li> If BLACS is first initialised through MatrixSwitch with <code>ms_scalapack_setup</code>, <code>ms_lap_icontxt</code> can then be used as the context handle for BLACS operations outside of MatrixSwitch.
</li>
</ul>
<hr />
<h3><span class="mw-headline" id="Public_types">Public types</span></h3>
<hr />
<p><code>type matrix</code>
</p><p>This is the derived type that encapsulates all matrix storage possibilities and hides the details from the user. Typically, the elements below will never need to be accessed directly.
</p>
<ul>
<li> <code>str_type</code> CHARACTER*3<br />Label identifying the storage format.
</li>
<li> <code>is_initialized</code> LOGICAL<br /><code>T</code>: Matrix has been initialized (with <code>m_allocate</code> or one of the <code>m_register</code> routines).<br /><code>F</code>: Matrix has not been initialized.
</li>
<li> <code>is_serial</code> LOGICAL<br /><code>T</code>: Matrix is serial distributed.<br /><code>F</code>: Matrix is parallel distributed.
</li>
<li> <code>is_real</code> LOGICAL<br /><code>T</code>: Matrix is real (DOUBLE PRECISION default).<br /><code>F</code>: Matrix is complex (COMPLEX*16 default).
</li>
<li> <code>is_square</code> LOGICAL<br /><code>T</code>: Matrix is square.<br /><code>F</code>: Matrix is non-square.
</li>
<li> <code>dim1</code> INTEGER<br /> Row dimension size of the matrix.
</li>
<li> <code>dim2</code> INTEGER<br /> Column dimension size of the matrix.
</li>
<li> <code>iaux1</code> INTEGER pointer, dimension (<code>:</code>)<br /> Auxiliary information for certain storage formats.
</li>
<li> <code>iaux2</code> INTEGER pointer, dimension (<code>:</code>)<br /> Auxiliary information for certain storage formats.
</li>
<li> <code>dval</code> DOUBLE PRECISION pointer, dimension (<code>:</code>,<code>:</code>)<br /> Matrix elements for a real matrix.
</li>
<li> <code>zval</code> COMPLEX*16 pointer, dimension (<code>:</code>,<code>:</code>)<br />Matrix elements for a complex matrix.
</li>
</ul>
<hr />
<h3><span class="mw-headline" id="Public_subroutines">Public subroutines</span></h3>
<h4><span class="mw-headline" id="Matrix_setup.2Fcreation.2Fdestruction">Matrix setup/creation/destruction</span></h4>
<hr />
<p><code>subroutine m_allocate( m_name, i, j, label )</code>
</p><p>Initialises a TYPE(MATRIX) variable by saving some basic information about the matrix, and allocating the necessary arrays for the requested storage format. Matrix elements are set to zero.
</p>
<ul>
<li> <code>m_name</code> (input/output) TYPE(MATRIX)<br /> The matrix to be allocated.
</li>
<li> <code>i</code> (input) INTEGER<br /> Row dimension size of the matrix.
</li>
<li> <code>j</code> (input) INTEGER<br /> Column dimension size of the matrix.
</li>
<li> <code>label</code> (input, optional) CHARACTER*5<br /> Storage format to use. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#Storage_formats" title="MatrixSwitch">list of available formats</a>. Default is <code>sdden</code>.
</li>
</ul>
<hr />
<p><code>subroutine m_deallocate( m_name )</code>
</p><p>Deallocates any allocated arrays in a TYPE(MATRIX) variable. For a registered matrix, the pointers are nullified.
</p>
<ul>
<li> <code>m_name</code> (input/output) TYPE(MATRIX)<br /> The matrix to be deallocated.
</li>
</ul>
<hr />
<p><code>subroutine m_register_sden( m_name, A )</code>
</p><p>[<span style="color: red"><code>s?den</code></span>] Registers pre-existing matrix data into a TYPE(MATRIX) variable with <code>s?den</code> format.
</p>
<ul>
<li> <code>m_name</code> (input/output) TYPE(MATRIX)<br /> The matrix to be allocated.
</li>
<li> <code>A</code> (input) DOUBLE PRECISION/COMPLEX*16 array, dimension (<code>:</code>,<code>:</code>)<br /> The values of the matrix elements, stored as a two-dimensional array.
</li>
</ul>
<hr />
<p><code>subroutine ms_scalapack_setup( mpi_size, nprow, order, bs_def, bs_list, icontxt )</code>
</p><p>[<span style="color: red"><code>p?dbc</code></span>] Sets up everything needed to use <code>p?dbc</code> matrices with ScaLAPACK. Has to be called once at the start of the code.
</p>
<ul>
<li> <code>mpi_size</code> (input) INTEGER<br /> The total number of MPI processes for the BLACS process grid.
</li>
<li> <code>nprow</code> (input) INTEGER<br /> Row dimension of the process grid (has to be a divisor of <code>mpi_size</code>).
</li>
<li> <code>order</code> (input) CHARACTER*1<br /> Ordering of the process grid:<br /><code>c</code>/<code>C</code>: column-major ordering<br /><code>r</code>/<code>R</code>/other: row-major ordering
</li>
<li> <code>bs_def</code> (input) INTEGER<br /> Default block size to use when allocating <code>p?dbc</code> matrices.
</li>
<li> <code>bs_list</code> (input, optional) INTEGER array, dimension (<code>:</code>)<br /> List of exceptions to <code>bs_def</code> to use for specific matrix dimension sizes. Has to be formatted as (<code>dim_1</code>,<code>bs_1</code>,<code>dim_2</code>,<code>bs_2</code>,etc.), where <code>dim_x</code> is the matrix dimension size, and <code>bs_x</code> is the corresponding block size to use for it.
</li>
<li> <code>icontxt</code> (input, optional) INTEGER<br /> BLACS context handle, if already initialised (see <code>ms_lap_icontxt</code>).
</li>
</ul>
<hr />
<p><code>subroutine m_register_pdbc( m_name, A, desc )</code>
</p><p>[<span style="color: red"><code>p?dbc</code></span>] Registers pre-existing matrix data into a TYPE(MATRIX) variable with <code>p?dbc</code> format.
</p>
<ul>
<li> <code>m_name</code> (input/output) TYPE(MATRIX)<br /> The matrix to be allocated.
</li>
<li> <code>A</code> (input) DOUBLE PRECISION/COMPLEX*16 array, dimension (<code>:</code>,<code>:</code>)<br /> The values of the local matrix elements, stored as a two-dimensional array.
</li>
<li> <code>desc</code> (input) INTEGER array, dimension (<code>9</code>)<br /> BLACS array descriptor.
</li>
</ul>
<hr />
<h4><span class="mw-headline" id="Matrix_operations">Matrix operations</span></h4>
<hr />
<p><code>subroutine mm_multiply( A, opA, B, opB, C, alpha, beta, label )</code>
</p><p>Performs the operation:
</p><p><img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {C}}\leftarrow \alpha {\tilde  {{\mathbf  {A}}}}{\tilde  {{\mathbf  {B}}}}+\beta {\mathbf  {C}}" src="../../../../../math/1/3/1/131ef797b5c0e7eb139a7b88c0368279.png" />, where <img class="mwe-math-fallback-png-inline tex" alt="{\tilde  {{\mathbf  {M}}}}={\begin{cases}{\mathbf  {M}}\\{\mathbf  {M}}^{{\mathrm  {T}}}\\{\mathbf  {M}}^{{\mathrm  {H}}}\end{cases}}" src="../../../../../math/a/2/0/a20cd06fc2a841569291c53bf06289b6.png" />
</p>
<ul>
<li> <code>A</code> (input) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}" src="../../../../../math/9/2/5/92555f9439ef4a54fcd65bd62f44f4ee.png" />. Note that the definition of the matrix (real/complex) needs to be the same as for the other matrices.
</li>
<li> <code>opA</code> (input) CHARACTER*1<br /> Form of <img class="mwe-math-fallback-png-inline tex" alt="{\tilde  {{\mathbf  {A}}}}" src="../../../../../math/b/7/5/b75be585edc543f6c626de9ec1241767.png" />:<br /><code>n</code>/<code>N</code>: <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}" src="../../../../../math/9/2/5/92555f9439ef4a54fcd65bd62f44f4ee.png" /><br /><code>t</code>/<code>T</code>: <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}^{{\mathrm  {T}}}" src="../../../../../math/f/5/a/f5a1478a479019d25e3aabee5554518b.png" /><br /><code>c</code>/<code>C</code>: <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}^{{\mathrm  {H}}}" src="../../../../../math/4/c/b/4cb9db0ecdf91a279c7958e13544cb82.png" /> (equivalent to <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}^{{\mathrm  {T}}}" src="../../../../../math/f/5/a/f5a1478a479019d25e3aabee5554518b.png" /> for a real matrix)
</li>
<li> <code>B</code> (input) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {B}}" src="../../../../../math/4/1/9/41968d7938b8145f26e1d196abc77144.png" />. Note that the definition of the matrix (real/complex) needs to be the same as for the other matrices.
</li>
<li> <code>opB</code> (input) CHARACTER*1<br /> Form of <img class="mwe-math-fallback-png-inline tex" alt="{\tilde  {{\mathbf  {B}}}}" src="../../../../../math/0/3/c/03c8e610d45618f2d987d1bebd528fcf.png" />:<br /><code>n</code>/<code>N</code>: <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {B}}" src="../../../../../math/4/1/9/41968d7938b8145f26e1d196abc77144.png" /><br /><code>t</code>/<code>T</code>: <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {B}}^{{\mathrm  {T}}}" src="../../../../../math/5/d/c/5dc3fd7a651cd3ea91526c71b2b87946.png" /><br /><code>c</code>/<code>C</code>: <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {B}}^{{\mathrm  {H}}}" src="../../../../../math/9/3/5/9353031f1c94deda6bfe1074c6015e89.png" /> (equivalent to <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {B}}^{{\mathrm  {T}}}" src="../../../../../math/5/d/c/5dc3fd7a651cd3ea91526c71b2b87946.png" /> for a real matrix)
</li>
<li> <code>C</code> (input/output) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {C}}" src="../../../../../math/3/9/6/39652eaf6bb68bf9769f17cb8088fece.png" />. Note that the definition of the matrix (real/complex) needs to be the same as for the other matrices.
</li>
<li> <code>alpha</code> (input) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\alpha " src="../../../../../math/b/c/c/bccfc7022dfb945174d9bcebad2297bb.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrices (real/complex); otherwise, it only has to match the type of <code>beta</code>, and will be automatically converted to match the matrices.
</li>
<li> <code>beta</code> (input) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\beta " src="../../../../../math/0/7/1/071997f13634882f823041b057f90923.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrices (real/complex); otherwise, it only has to match the type of <code>alpha</code>, and will be automatically converted to match the matrices.
</li>
<li> <code>label</code> (input, optional) CHARACTER*3<br /> Implementation of the operation to use. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#mm_multiply" title="MatrixSwitch">list of available implementations</a>.
</li>
</ul>
<hr />
<p><code>subroutine m_add ( A, opA, C, alpha, beta, label )</code>
</p><p>Performs the operation:
</p><p><img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {C}}\leftarrow \alpha {\tilde  {{\mathbf  {A}}}}+\beta {\mathbf  {C}}" src="../../../../../math/c/8/2/c826e6830338fba91874d9857b858404.png" />, where <img class="mwe-math-fallback-png-inline tex" alt="{\tilde  {{\mathbf  {M}}}}={\begin{cases}{\mathbf  {M}}\\{\mathbf  {M}}^{{\mathrm  {T}}}\\{\mathbf  {M}}^{{\mathrm  {H}}}\end{cases}}" src="../../../../../math/a/2/0/a20cd06fc2a841569291c53bf06289b6.png" />
</p>
<ul>
<li> <code>A</code> (input) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}" src="../../../../../math/9/2/5/92555f9439ef4a54fcd65bd62f44f4ee.png" />. Note that the definition of the matrix (real/complex) needs to be the same as for the other matrix.
</li>
<li> <code>opA</code> (input) CHARACTER*1<br /> Form of <img class="mwe-math-fallback-png-inline tex" alt="{\tilde  {{\mathbf  {A}}}}" src="../../../../../math/b/7/5/b75be585edc543f6c626de9ec1241767.png" />:<br /><code>n</code>/<code>N</code>: <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}" src="../../../../../math/9/2/5/92555f9439ef4a54fcd65bd62f44f4ee.png" /><br /><code>t</code>/<code>T</code>: <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}^{{\mathrm  {T}}}" src="../../../../../math/f/5/a/f5a1478a479019d25e3aabee5554518b.png" /><br /><code>c</code>/<code>C</code>: <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}^{{\mathrm  {H}}}" src="../../../../../math/4/c/b/4cb9db0ecdf91a279c7958e13544cb82.png" /> (equivalent to <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}^{{\mathrm  {T}}}" src="../../../../../math/f/5/a/f5a1478a479019d25e3aabee5554518b.png" /> for a real matrix)
</li>
<li> <code>C</code> (input/output) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {C}}" src="../../../../../math/3/9/6/39652eaf6bb68bf9769f17cb8088fece.png" />. Note that the definition of the matrix (real/complex) needs to be the same as for the other matrix.
</li>
<li> <code>alpha</code> (input) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\alpha " src="../../../../../math/b/c/c/bccfc7022dfb945174d9bcebad2297bb.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrices (real/complex); otherwise, it only has to match the type of <code>beta</code>, and will be automatically converted to match the matrices.
</li>
<li> <code>beta</code> (input) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\beta " src="../../../../../math/0/7/1/071997f13634882f823041b057f90923.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrices (real/complex); otherwise, it only has to match the type of <code>alpha</code>, and will be automatically converted to match the matrices.
</li>
<li> <code>label</code> (input, optional) CHARACTER*3<br /> Implementation of the operation to use. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#m_add" title="MatrixSwitch">list of available implementations</a>.
</li>
</ul>
<hr />
<p><code>subroutine m_trace( A, alpha, label )</code>
</p><p>Performs the operation:
</p><p><img class="mwe-math-fallback-png-inline tex" alt="\alpha \leftarrow \operatorname {tr}\left({\mathbf  {A}}\right)" src="../../../../../math/d/4/9/d494bd9a8d91bb0cb779a572a27e3716.png" />
</p>
<ul>
<li> <code>A</code> (input) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}" src="../../../../../math/9/2/5/92555f9439ef4a54fcd65bd62f44f4ee.png" />.
</li>
<li> <code>alpha</code> (output) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\alpha " src="../../../../../math/b/c/c/bccfc7022dfb945174d9bcebad2297bb.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrix (real/complex); otherwise, it will be automatically converted to match it.
</li>
<li> <code>label</code> (input, optional) CHARACTER*3<br /> Implementation of the operation to use. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#m_trace" title="MatrixSwitch">list of available implementations</a>.
</li>
</ul>
<hr />
<p><code>subroutine mm_trace( A, B, alpha, label )</code>
</p><p>Performs the operation:
</p><p><img class="mwe-math-fallback-png-inline tex" alt="\alpha \leftarrow \operatorname {tr}\left({\mathbf  {A}}^{{\mathrm  {H}}}{\mathbf  {B}}\right)\equiv \operatorname {tr}\left({\mathbf  {B}}{\mathbf  {A}}^{{\mathrm  {H}}}\right)" src="../../../../../math/7/3/e/73e7f618826cf164d8d604dd888342d8.png" />
</p>
<ul>
<li> <code>A</code> (input) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {A}}" src="../../../../../math/9/2/5/92555f9439ef4a54fcd65bd62f44f4ee.png" />. Note that the definition of the matrix (real/complex) needs to be the same as for the other matrix.
</li>
<li> <code>B</code> (input) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {B}}" src="../../../../../math/4/1/9/41968d7938b8145f26e1d196abc77144.png" />. Note that the definition of the matrix (real/complex) needs to be the same as for the other matrix.
</li>
<li> <code>alpha</code> (output) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\alpha " src="../../../../../math/b/c/c/bccfc7022dfb945174d9bcebad2297bb.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrices (real/complex); otherwise, it will be automatically converted to match them.
</li>
<li> <code>label</code> (input, optional) CHARACTER*3<br /> Implementation of the operation to use. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#mm_trace" title="MatrixSwitch">list of available implementations</a>.
</li>
</ul>
<hr />
<p><code>subroutine m_scale ( C, beta, label )</code>
</p><p>Performs the operation:
</p><p><img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {C}}\leftarrow \beta {\mathbf  {C}}" src="../../../../../math/4/3/7/437c19fba65ad3c5d5e7053e6a29864d.png" />
</p>
<ul>
<li> <code>C</code> (input/output) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {C}}" src="../../../../../math/3/9/6/39652eaf6bb68bf9769f17cb8088fece.png" />.
</li>
<li> <code>beta</code> (input) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\beta " src="../../../../../math/0/7/1/071997f13634882f823041b057f90923.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrix (real/complex); otherwise, it will be automatically converted to match it.
</li>
<li> <code>label</code> (input, optional) CHARACTER*3<br /> Implementation of the operation to use. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#m_scale" title="MatrixSwitch">list of available implementations</a>.
</li>
</ul>
<hr />
<p><code>subroutine m_set( C, seC, alpha, beta, label )</code>
</p><p>Performs the operation:
</p><p><img class="mwe-math-fallback-png-inline tex" alt="\left[{\mathbf  {C}}\right]_{{i,j}}\leftarrow {\begin{cases}\alpha ,&amp;i\neq j\\\beta ,&amp;i=j\end{cases}}" src="../../../../../math/4/f/e/4fe127b4301b50e727a78bedd2145480.png" /> for either all matrix elements, or only the lower/upper triangle (generalised to elements below/above the diagonal for rectangular matrices)
</p>
<ul>
<li> <code>C</code> (input/output) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {C}}" src="../../../../../math/3/9/6/39652eaf6bb68bf9769f17cb8088fece.png" />.
</li>
<li> <code>seC</code> (input) CHARACTER*1<br /> Form of the operation:<br /><code>l</code>/<code>L</code>: lower triangle<br /><code>u</code>/<code>U</code>: upper triangle<br />other: complete matrix
</li>
<li> <code>alpha</code> (input) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\alpha " src="../../../../../math/b/c/c/bccfc7022dfb945174d9bcebad2297bb.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrix (real/complex); otherwise, it only has to match the type of <code>beta</code>, and will be automatically converted to match the matrix.
</li>
<li> <code>beta</code> (input) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\beta " src="../../../../../math/0/7/1/071997f13634882f823041b057f90923.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrix (real/complex); otherwise, it only has to match the type of <code>alpha</code>, and will be automatically converted to match the matrix.
</li>
<li> <code>label</code> (input, optional) CHARACTER*3<br /> Implementation of the operation to use. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#m_set" title="MatrixSwitch">list of available implementations</a>.
</li>
</ul>
<hr />
<p><code>subroutine m_set_element( C, i, j, alpha, label )</code>
</p><p>Performs the operation:
</p><p><img class="mwe-math-fallback-png-inline tex" alt="\left[{\mathbf  {C}}\right]_{{i,j}}\leftarrow \alpha " src="../../../../../math/6/2/b/62b08fda274c847905e46108aea2441d.png" /> for one matrix element
</p>
<ul>
<li> <code>C</code> (input/output) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {C}}" src="../../../../../math/3/9/6/39652eaf6bb68bf9769f17cb8088fece.png" />.
</li>
<li> <code>i</code> (input) INTEGER<br /> Row index of the element.
</li>
<li> <code>j</code> (input) INTEGER<br /> Column index of the element.
</li>
<li> <code>alpha</code> (input) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\alpha " src="../../../../../math/b/c/c/bccfc7022dfb945174d9bcebad2297bb.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrix (real/complex); otherwise, it will be automatically converted to match it.
</li>
<li> <code>label</code> (input, optional) CHARACTER*3<br /> Implementation of the operation to use. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#m_set_element" title="MatrixSwitch">list of available implementations</a>.
</li>
</ul>
<hr />
<p><code>subroutine m_get_element( C, i, j, alpha, label )</code>
</p><p>Performs the operation:
</p><p><img class="mwe-math-fallback-png-inline tex" alt="\alpha \leftarrow \left[{\mathbf  {C}}\right]_{{i,j}}" src="../../../../../math/c/8/0/c8022f8116b190fa0e57cb1621e4b69f.png" /> for one matrix element
</p>
<ul>
<li> <code>C</code> (input) TYPE(MATRIX)<br /> Matrix <img class="mwe-math-fallback-png-inline tex" alt="{\mathbf  {C}}" src="../../../../../math/3/9/6/39652eaf6bb68bf9769f17cb8088fece.png" />.
</li>
<li> <code>i</code> (input) INTEGER<br /> Row index of the element.
</li>
<li> <code>j</code> (input) INTEGER<br /> Column index of the element.
</li>
<li> <code>alpha</code> (output) DOUBLE PRECISION/COMPLEX*16<br /> Scalar <img class="mwe-math-fallback-png-inline tex" alt="\alpha " src="../../../../../math/b/c/c/bccfc7022dfb945174d9bcebad2297bb.png" />. If the library is compiler without the <code>-DCONV</code> flag, the type has to match the definition of the matrix (real/complex); otherwise, it will be automatically converted to match it.
</li>
<li> <code>label</code> (input, optional) CHARACTER*3<br /> Implementation of the operation to use. See the <a href="../../../../articles/m/a/t/MatrixSwitch.html#m_get_element" title="MatrixSwitch">list of available implementations</a>.
</li>
</ul>
<hr />

<!-- 
NewPP limit report
CPU time usage: 0.265 seconds
Real time usage: 0.512 seconds
Preprocessor visited node count: 372/1000000
Preprocessor generated node count: 1370/1000000
Postâ€expand include size: 540/2097152 bytes
Template argument size: 249/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->
</div><div class="printfooter">
</div>
	    <div id="catlinks"><div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://esl.cecam.org/mediawiki/index.php/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="../../../../articles/e/s/l/Category:ESL_entries.html" title="Category:ESL entries">ESL entries</a></li><li><a href="http://esl.cecam.org/mediawiki/index.php?title=Category:Functionalities&amp;action=edit&amp;redlink=1" class="new" title="Category:Functionalities (page does not exist)">Functionalities</a></li><li><a href="../../../../articles/a/p/i/Category:APIs.html" title="Category:APIs">APIs</a></li><li><a href="http://esl.cecam.org/mediawiki/index.php?title=Category:Software&amp;action=edit&amp;redlink=1" class="new" title="Category:Software (page does not exist)">Software</a></li><li><a href="../../../../articles/s/o/l/Category:Solvers.html" title="Category:Solvers">Solvers</a></li><li><a href="http://esl.cecam.org/mediawiki/index.php?title=Category:Sparse_matrices&amp;action=edit&amp;redlink=1" class="new" title="Category:Sparse matrices (page does not exist)">Sparse matrices</a></li></ul></div></div></div>	    <!-- end content -->
	    <div class="visualClear"></div>
	  </div>
	</div>
      </div>
      <div id="column-one">
	<div id="p-cactions" class="portlet">
	  <h5>Views</h5>
	  <ul>
	    <li id="ca-nstab-main"
	       class="selected"	       ><a href="../../../../articles/m/a/t/MatrixSwitch.html">Page</a></li><li id="ca-talk"
	       class="new"	       ><a href="http://esl.cecam.org/mediawiki/index.php?title=Talk:MatrixSwitch&amp;action=edit&amp;redlink=1">Discussion</a></li><li id="ca-current"
	       	       ><a href="http://esl.cecam.org/mediawiki/index.php/MatrixSwitch">Latest revision</a></li>	  </ul>
	</div>
	<div class="portlet" id="p-logo">
	  <a style="background-image: url(../../../../misc/esl_wiki_logo.png);"
	    href="../../../../index.html"
	    title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
	  <h5>Navigation</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-mainpage-description"><a href="../../../../index.html">Main page</a></li>
	     	      <li id="n-About-ESL"><a href="../../../../articles/a/b/o/ESL:About.html">About ESL</a></li>
	     	      <li id="n-Contributing"><a href="../../../../articles/c/o/n/Contributing.html">Contributing</a></li>
	     	      <li id="n-Credits"><a href="../../../../articles/c/r/e/Credits.html">Credits</a></li>
	     	      <li id="n-Contact"><a href="../../../../articles/c/o/n/Contact.html">Contact</a></li>
	     	      <li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents">Help</a></li>
	     	    </ul>
	  </div>
	</div>
		<div class='portlet' id='p-SEARCH'>
	  <h5>SEARCH</h5>
	  <div class='pBody'>
	    <ul>
	    	    </ul>
	  </div>
	</div>
		<div class='portlet' id='p-TOOLBOX'>
	  <h5>TOOLBOX</h5>
	  <div class='pBody'>
	    <ul>
	    	    </ul>
	  </div>
	</div>
		<div class='portlet' id='p-LANGUAGES'>
	  <h5>LANGUAGES</h5>
	  <div class='pBody'>
	    <ul>
	    	    </ul>
	  </div>
	</div>
		<div id="p-search" class="portlet">
	  <h5><label for="searchInput">Search</label></h5>
	  <div id="searchBody" class="pBody">
	    <form action="javascript:goToStatic(3)" id="searchform"><div>
	      <input id="searchInput" name="search" type="text"
	        accesskey="f" value="" />
	      <input type='submit' name="go" class="searchButton" id="searchGoButton"
	        value="Go" />
	    </div></form>
	  </div>
	</div>
	      </div><!-- end of the left (by default at least) column -->
      <div class="visualClear"></div>
      <div id="footer">
    <div id="f-poweredbyico"><a href="//www.mediawiki.org/"><img src="../../../../skins/common/images/poweredby_mediawiki_88x31.png" height="31" width="88" alt="Powered by MediaWiki" /></a></div>		<ul id="f-list">
	  	  	  <li id="f-credits">This page was last modified 17:21, 25 July 2014 by <a href="../../../../articles/f/a/b/User:Fabiano.corsetti.html" title="User:Fabiano.corsetti">Fabiano Corsetti</a>. Based on work by ESL user <a href="http://esl.cecam.org/mediawiki/index.php?title=User:Admin&amp;action=edit&amp;redlink=1" class="new" title="User:Admin (page does not exist)">Admin</a>.</li>	  	  <li id="f-about"><a href="../../../../articles/a/b/o/ESL:About.html" title="ESL:About">About ESL</a></li>	  <li id="f-disclaimer"><a href="../../../../articles/g/e/n/ESL:General_disclaimer.html" title="ESL:General disclaimer">Disclaimers</a></li>	  	</ul>
      </div>
    </div>
  </body>
</html>
